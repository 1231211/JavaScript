<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>闭包</title>
    <script src="../jquery.min.js"></script>
</head>
<body>
<script>
    // 函数内部可以直接读取全局变量
    //  var n = 99;
    //  function f1() {
    //    alert(n);
    //  }
    //  f1();

    //函数外部无法读取函数内部的局部变量，这里会报错
    //  function f2() {
    //    m = 99;
    //  }
    //  f2();
    //  alert(m)

    //  //正常情况下无法读取到函数内部的局域变量，可以通过变通方法获取，如下在函数f3内部定义一个函数f4，在f4内部读取f3的变量并返回这
    //  //函数f4，外部将f3函数赋值给一个变量，再调用这个变量
    //  function f3() {
    //    var a = 999;
    //
    //    function f4() {
    //      alert(a);
    //    }
    //    return f4
    //  }
    //  var result = f3();
    //  result();

    //
    //  //上面f4就是一个闭包函数，用它来读取函数f3内部的变量，闭包可以把函数内部和外部连接起来，闭包函数还可以让变量始终保持在内存中
    //  function f5() {
    //    var b = 111;
    //    nAdd = function () {
    //      b += 1;
    //    }
    //    function f6() {
    //      alert(b);
    //    }
    //    return f6
    //  }
    //  var result1 = f5();
    //  result1();
    //  nAdd();
    //  result1();
    //
    //  var name = 'The Window';
    //  var object = {
    //    name: 'My Object',
    //    getNameFunc: function () {
    //      // 这里的this是函数
    //      console.info(this)
    //      return function () {
    //        //匿名函数的执行环境是windows
    //        console.info(this)
    //        return this.name;
    //      }
    //    }
    //  };
    //  alert(object.getNameFunc()());

    //  var name1 = "The Window";
    //  var object1 = {
    //    name1: 'My Object1',
    //    getNameFunc:function () {
    //      return  () => {
    //        return this.name1
    //      }
    //    }
    //  }
    //  alert(object1.getNameFunc()());
    //
    //  var foo = function(){
    //    var name = "exe";
    //    return function inner(){
    //      console.log( name );
    //    }
    //  }
    //  var bar = foo();//这里虽然得到的是函数inner的引用，而不是那一坨代码
    //  bar();//这里开始执行inner函数，回头看看上面加粗的那句话


    //let命令只在代码块内有效，在下面的代码块中分别使用let和var声明2个变量，在代码块外面访问，let声明的会报错，var不会报错
    //  function  a() {
    //    var c = 2;
    //  }
    //  {
    //    let a = 10;
    //    var b = 1;
    //  }
    //  alert(c);
    //  alert(b);

    //在for循环中很适合使用let命令


    //  var tmp = new Date();
    //  function f6() {
    //    console.log(tmp);
    //    if(false){
    //      tmp = "hello world";
    //    }
    //  }
    //  f6();


    // for(var i = 0; i < 5; i++){
    //     setTimeout(function () {
    //         console.log(new Date, i);
    //     }, 1000)
    // }
    // console.log(new Date, i);

    // for (var i = 0; i < 5; i++) {
    //     (function (j) {
    //         setTimeout(function () {
    //             console.log(new Date, j);
    //         }, 1000)
    //     })(i);
    // }
    // console.log(new Date, i);


    /**
     * 传入参数
     * /
    // function output (i) {
    //     setTimeout(function () {
    //         console.log(new Date, i);
    //     }, 1000);
    // };
    // for (var i = 0; i < 5; i++) {
    //     output(i);
    // }
    // console.log(new Date, i);


    /**
     * 立即执行表达式
     * /
    // for (let i = 0; i < 5; i++) {
    //     setTimeout(function () {
    //         console.log(new Date, i);
    //     }, 1000);
    // }
    // console.log(new Date, i);

    // for (var i = 0; i < 5; i++) {
    //     (function (j) {
    //         setTimeout(function () {
    //             console.log(new Date, j);
    //         }, 1000 * j);
    //     })(i);
    // }
    // setTimeout(function () {
    //     console.log(new Date, i);
    // }, 1000 * i);

    /**
     * Promise实现
     * */
    // const task = [];
    // for (var i = 0; i < 5; i++) {
    //     (j => {
    //         task.push(new Promise(resolve => {
    //             setTimeout(() => {
    //                 console.log(new Date, j);
    //                 resolve(); // 一定要改变状态
    //             }, 1000 * j);
    //         }))
    //     })(i);
    // }
    //
    // Promise.all(task).then(() => {
    //     setTimeout(() => {
    //         console.log(new Date, i);
    //     }, 1000);
    // });

    /**
     * Promise实现
     * */
    // const task = []
    // const output = i => new Promise(resolve => {
    //     setTimeout(() => {
    //         console.log(new Date(), i);
    //         resolve()
    //     }, 1000 * i)
    // })
    //
    // for (var i = 0; i < 5; i++) {
    //     task.push(output(i))
    // }
    //
    // Promise.all(task).then(() => {
    //     setTimeout(() => {
    //         console.log(new Date(), i);
    //     }, 1000)
    // })


    /**
     * async，await实现
     */
    // const sleep = timeountMS => new Promise(resolve => {
    //     setTimeout(resolve, timeountMS);
    // });
    //
    // (async () => {
    //     for (var i = 0; i < 5; i++) {
    //         await sleep(1000)
    //         console.log(new Date(), i);
    //     }
    //     await sleep(1000)
    //     console.log(new Date(), i);
    // })()
</script>
</body>
</html>